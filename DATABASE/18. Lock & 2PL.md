# 18. Lock & 2PL

## Lock 개념의 도입

지금까지 살펴본 트랜잭션 스케줄의 여러 문제점을 해결하기 위해 DBMS는 CPU 스케줄링에서도 쓰이는 기법인, Lock 개념을 도입했다. 트랜잭션 스케줄링의 락은 CPU 스케줄링의 락과 동일한 개념으로 **특정 자원에 대한 접근권한**을 의미한다.

예를 들어 옷가게에서 옷을 피팅해볼 때, 피팅룸에 들어가서 시착을 해볼 수 있다. 이 때 피팅룸 앞에는 사람들이 줄을 서서 차례를 기다리고 있고, 피팅룸 안에는 한 명씩만 들어가서 이용할 수 있다. 피팅룸에 사람이 들어가면 문을 잠구기 때문에 다른 사람은 피팅룸을 이용할 수 없다. 한 사람의 차례가 끝나면 다음 순서 사람이 들어가서 피팅룸을 이용한다. 

여기에서 피팅룸은 자원(데이터)를 의미하고 피팅룸에 들어가서 옷을 갈아입는 것은 자원(데이터를)을 읽거나 쓰는 등 접근하는 것을 의미한다. 그리고 락을 획득하고 해제하는 것은 피팅룸에 들어갈 때 문을 잠그고, 나올 때 푸는 것과 같다.

락의 종류엔 두 가지가 있다.

- write-lock(exclusive lock) : 데이터를 읽거나, 쓸 수 있는 락. 주로 쓰기 작업 시 사용됨.
- read-lock(shared lock) : 데이터를 읽기만 할 수 있는 락. 주로 읽기 작업 시 사용됨.

write-lock은 exclusive(독점적인) 락이므로, 한 트랜잭션이 write-lock을 가져가면, 다른 트랜잭션은 그 데이터에 대해 어떠한 락도 가져올 수 없다.

read-lock은 shared(공유하는) 락이므로, 한 트랜잭션이 read-lock을 가져갔을 때, 다른 트랜잭션은 그 데이터에 대한 read-lock은 가져올 수 있다. 하지만 write-lock은 가져올 수 없다.

**lock 호환성**

|  | read-lock | write-lock |
| --- | --- | --- |
| read-lock | O | X |
| write-lock | X | X |

### lock을 도입하는 것 만으로는 안된다

아래의 예시를 보자.

![image](https://github.com/Minnie5382/cs-study-db/assets/97179789/9eaf1541-2625-4c26-a2d6-1c8f99160c78)

tx1과 tx2가 각각 저렇게 있다. 이 두 트랜잭션을 serial schedule로 실행했을 때의 결과가 왼쪽 하단에 나와있다.

<img width='350px' src='https://github.com/Minnie5382/cs-study-db/assets/97179789/bca7547b-e7e5-4c36-a030-64adfa153168' >

이는 직관적으로 조금만 생각해보면 알 수 있다. 

이제 두 트랜잭션이 동시에 실행, 득 non-serial schedule로 실행되는 상황에 Lock 개념을 도입한 스케줄을 살펴보자.

<img width='700px' src='https://github.com/Minnie5382/cs-study-db/assets/97179789/53efa947-ccea-4aee-9b46-1ebfda2803d7' >

이 스케줄은 분명히 락 규칙을 철저히 지키고 있다. 작업 순서를 살펴보면 tx2가 x를 읽고 → tx1이 y를 읽고 → tx2가 y를 읽고 → tx2가 y를 쓰고 →  tx1이 x를 읽고 → tx1이 x를 쓴다.

이 스케줄의 실행 결과는 `x = 300, y = 300` 이다. 두 serial schedule의 결과 중 어떤 것과도 같지 않다. serializable schedule의 정의가 뭐였는지 기억하는가? serial schedule과 동일한 결과를 내는 non-serial schedule. 즉 **락을 도입하는 것 만으로는 스케줄을 serializable하게 만들 수가 없다.**

이렇게 되는 원인이 무엇일까? 

<img width='350px' src='https://github.com/Minnie5382/cs-study-db/assets/97179789/9f431288-1ffa-4bc2-a274-c087dcd7b56d' >

바로 저 노란색 하이라이트 된 부분 때문이다. 원래는 tx2가 먼저 실행되어 x를 먼저 읽었기 때문에, tx1은 업데이트된 y를 읽어야 serializable하게 진행될 수 있다. 하지만 이 스케줄에서는 tx2가 x를 읽자마자 unlock을 해버렸기 때문에 tx2가 다시 write-lock을 획득하려는 틈에 tx1이 먼저 read-lock을 획득해버린다. 그러는 바람에 tx2의 진행은 멈췄고 그 사이 tx1이 아직 업데이트 되지 않은 y를 읽어버린다. 여기서부터 모든 게 꼬이시 시작한 것이다. 

이걸 해결해주기 위해선 unlock의 타이밍을 바꿔야 한다. write-lock까지 다 획득하고 난 후에 이전 lock을 풀게 되면 tx2가 y를 다 쓸 때 까지 tx1은 y를 읽을 수 없다. 이를 일반화하면, **트랜잭션은 필요한 모든 lock을 획득하는 작업을 먼저 해야한다. 이후 작업을 처리한 다음에 unlock 해주면 된다. 이런 스케줄링 방식을 2PL 프로토콜이라고 한다.**

## 2PL(2-Phase Locking) 프로토콜

락을 획득하는 단계(Expanding phase)와 락을 해제하는 단계(Shrinking phase)를 따로 나누는 방식을 의미한다. 순서는 expanding phase가 첫번째, shrinking phase가 두번째이다. 이 프로토콜은 Serializability를 보장한다.

<img width='550px' src='https://github.com/Minnie5382/cs-study-db/assets/97179789/4cbfeed9-ad6e-48e5-b241-3201562ceda5' >


### 2PL 프로토콜의 문제점 - Deadlock(교착 상태)

<img width='800px' src='https://github.com/Minnie5382/cs-study-db/assets/97179789/71548958-a9b1-439c-ae50-963d5d9b2331' >


Deadlock(교착 상태)는 락을 사용하는 CPU 스케줄링에서도 동일하게 발생하는 현상이다. expanding phase에서 양측 트랜잭션이 락을 획득하다가, 서로의 락에 걸려서 서로의 락을 획득하기 못한 채 갇혀버리는 상황을 의미한다. 

위 그림에서는 tx1은 wrtie-lock(x)를 획득하려고 시도했으나 tx2가 먼저 read-lock(x)를 획득했기 때문에 대기 중이고, tx2는 write-lock(y)를 획득하려 시도했으나 tx1이 먼저 read-lock(y)를 획득하여 대기중이다. 서로가 unlock을 하기를 기다리지만, expanding phase에서는 락을 획득하기만 하기 때문에 unlock는 하지 않는다. 이대로 두면 두 트랜잭션은 영원히 갇혀버리게 된다.

### Deadlock의 해결 방안

이는 CPU 스케줄링에서 데드락을 해결하는 방법과 동일하다. 혼공컴운 **13-2. 교착 상태의 해결 방법** 부분의 내용을 이해하면 도움이 될 것이다.

<aside>
➡️

### 교착 상태 발생 조건

- 교착 상태가 발생하는 조건은 4가지이며, 이 중 하나라도 충족하지 않으면 교착 상태는 발생하지 않는다.
1. 상호 배제 : 한 자원은 한번에 한 프로세스만 이용 가능하다.
2. 점유와 대기 : 프로세스가 자원을 보유한 채 다른 자원을 기다린다.
3. 비선점 : 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못한다.
4. 원형 대기 : 자원 할당 그래프가 원의 형태로 그려진다.

## 13-2. 교착 상태의 해결 방법

### 1. 교착 상태 예방

> 교착 상태 발생 조건 4가지 중, 한 가지라도 충족하지 못하게 하면 교착 상태가 발생할 수 없으므로 예방할 수 있다.
> 
1. ~~상호 배제를 없앤다.~~
    - ~~모든 자원을 동시에 여러 프로세스가 공유할 수 있게 한다. - ???~~
2. 점유와 대기를 없앤다.
    - 포크를 들 때는 양쪽 두 개를 동시에 들던가, 아니면 아예 안들던가!
    - 자원의 활용률↓
3. 비선점 조건을 없앤다.
    - 옆 철학자가 들고 있는 포크를 뺏을 수 있다.
    - 범용성↓
4. ~~원형 대기 조건을 없앤다.~~
    - ~~철학자들을 일렬로 앉힌다. - 모든 자원에 번호를 붙이고 오름차순 할당~~
    - ~~비용↑, 번호에 따라 자원 활용률↓~~

### 2. 교착 상태 회피

> 교착 상태가 발생하지 않을 정도로 적은 양의 자원만 배분하는 방법.
(포크 100개 준비해놓고, 한 개 씩만 배분하기)
> 
- 안전 상태 : 교착 상태가 발생하지 않는 상태 (안전 순서열 O)
- 안전 순서열 : 안전 상태에서 교착 상태 없이 안전하게 자원을 할당할 수 있는 순서
- 불안전 상태 : 교착 상태가 필연적으로 발생하는 상태 (안전 순서열X)
    
   
  <img width='450px' src='https://github.com/Minnie5382/cs-study-db/assets/97179789/47050a97-8dda-4cbf-8988-169d6e23ae5e' >


- 위의 경우 안전 순서열 : P2 → P1 → P3
- 안전 순서열이 존재하기 때문에, 안전 상태

### 3. 교착 상태 검출 후 회복

> 교착 상태가 발생했는지 주기적으로 검사, 검출되면 다음과 같은 방식으로 회복하는 방법
> 
1. 선점을 통한 회복
2. 프로세스 강제 종료를 통한 회복
    - 교착 상태에 놓인 프로세스 모두 강제 종료 : 많은 프로세스의 작업 내역 소실
    - 한 프로세스씩 강제 종료 : 오버 헤드↑
3. 타조 알고리즘
    - 드문 문제에 대해선 걍 마이웨이하는 개발자스러운 해결법
</aside>

### Conservative 2PL

- 트랜잭션이 시작하고 바로 모든 필요한 lock 획득을 진행하는 2PL
- deadlock-free
- 실용성↓

### Strict 2PL(S2PL)

- strict schedule*을 보장하는 2PL
- recoverability 보장
- 한 트랜잭션 내에서, 커밋된 이후에 write-lock에 대하여 unlock 한다.

*strict schedule: 동일한 데이터에 대해 write한 트랜잭션이 끝난 후에 다른 트랜잭션이 read 혹은 write 작업을 하는 스케줄

### Strong Strict 2PL(SS2PL, rigorous 2PL)

- strict schedule*을 보장하는 2PL
- recoverability 보장
- S2PL보다 구현이 쉬움
- 한 트랜잭션 내에서, 커밋된 이후에 모든 락에 대하여 unlock 한다.

### 이후에 뭐라뭐라 하는데 뭔소린지 모르겠고 관심 안가고 그냥 다음 강의에서 배울 MVCC랑 락이랑 짬뽕해서 쓰는 방법이 오늘날 가장 대중적인 방법이라고 합니다 네.
